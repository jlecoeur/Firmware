/****************************************************************************
 *
 *   Copyright (c) 2012-2016 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/**
 * @file mixer_multirotor_6dof.cpp
 *
 * Multi-rotor mixers, 6 degrees of freedom
 * 
 * @author Julien Lecoeur <julien.lecoeur@gmail.com>
 */

#include <px4_config.h>
#include <sys/types.h>
#include <stdint.h>
#include <stdbool.h>
#include <float.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <poll.h>
#include <errno.h>
#include <stdio.h>
#include <math.h>
#include <unistd.h>
#include <math.h>

#include <mathlib/math/Limits.hpp>
#include <drivers/drv_pwm_output.h>

#include "mixer.h"

// This file is generated by the px_generate_mixers.py script which is invoked during the build process
// #include "mixer_multirotor.generated.h"
#include "mixer_multirotor_6dof_normalized.generated.h"

#define debug(fmt, args...)	do { } while(0)
//#define debug(fmt, args...)	do { printf("[mixer] " fmt "\n", ##args); } while(0)
//#include <debug.h>
//#define debug(fmt, args...)	syslog(fmt "\n", ##args)

/*
 * Clockwise: 1
 * Counter-clockwise: -1
 */

MultirotorMixer6dof::MultirotorMixer6dof(ControlCallback control_cb,
				 uintptr_t cb_handle,
				 MultirotorGeometry geometry,
				 float roll_scale,
				 float pitch_scale,
				 float yaw_scale,
				 float x_scale,
				 float y_scale,
				 float z_scale,
				 float idle_speed) :
	Mixer(control_cb, cb_handle),
	_roll_scale(roll_scale),
	_pitch_scale(pitch_scale),
	_yaw_scale(yaw_scale),
	_x_scale(x_scale),
	_y_scale(y_scale),
	_z_scale(z_scale),
	_idle_speed(-1.0f + idle_speed * 2.0f),	/* shift to output range here to avoid runtime calculation */
	_delta_out_max(0.0f),
	_thrust_factor(0.0f),
	_rotor_count(_config_rotor_count[(MultirotorGeometryUnderlyingType)geometry]),
	_rotors(_config_index[(MultirotorGeometryUnderlyingType)geometry]),
	_outputs_prev(new float[_rotor_count])
{
	memset(_outputs_prev, _idle_speed, _rotor_count * sizeof(float));
}

MultirotorMixer6dof::~MultirotorMixer6dof()
{
	if (_outputs_prev != nullptr) {
		delete[] _outputs_prev;
	}
}

MultirotorMixer6dof *
MultirotorMixer6dof::from_text(Mixer::ControlCallback control_cb, uintptr_t cb_handle, const char *buf, unsigned &buflen)
{
	MultirotorGeometry geometry = MultirotorGeometry::MAX_GEOMETRY;
	char geomname[8];
	int s[7];
	int used;

	/* enforce that the mixer ends with a new line */
	if (!string_well_formed(buf, buflen)) {
		return nullptr;
	}

	if (sscanf(buf, "S: %7s %d %d %d %d %d %d %d%n", 
			   geomname, &s[0], &s[1], &s[2], &s[3], &s[4], &s[5], &s[6], &used) != 8) {
		debug("multirotor parse failed on '%s'", buf);
		return nullptr;
	}

	if (used > (int)buflen) {
		debug("OVERFLOW: multirotor spec used %d of %u", used, buflen);
		return nullptr;
	}

	buf = skipline(buf, buflen);

	if (buf == nullptr) {
		debug("no line ending, line is incomplete");
		return nullptr;
	}

	debug("remaining in buf: %d, first char: %c", buflen, buf[0]);

	for (MultirotorGeometryUnderlyingType i = 0; i < (MultirotorGeometryUnderlyingType)MultirotorGeometry::MAX_GEOMETRY;
	     i++) {
		if (!strcmp(geomname, _config_key[i])) {
			geometry = (MultirotorGeometry)i;
			break;
		}
	}

	if (geometry == MultirotorGeometry::MAX_GEOMETRY) {
		debug("unrecognised geometry '%s'", geomname);
		return nullptr;
	}

	debug("adding multirotor mixer '%s'", geomname);

	return new MultirotorMixer6dof(
		       control_cb,
		       cb_handle,
		       geometry,
		       s[0] / 10000.0f,
		       s[1] / 10000.0f,
		       s[2] / 10000.0f,
		       s[3] / 10000.0f,
		       s[4] / 10000.0f,
		       s[5] / 10000.0f,
		       s[6] / 10000.0f);
}

matrix::Vector<float, 6> 
MultirotorMixer6dof::get_command(void) const
{
	const float command_[6] = {
		math::constrain(get_control(0, actuator_controls_s::INDEX_ROLL) 	* _roll_scale,  -1.0f, 1.0f), 
		math::constrain(get_control(0, actuator_controls_s::INDEX_PITCH) 	* _pitch_scale, -1.0f, 1.0f),
		math::constrain(get_control(0, actuator_controls_s::INDEX_YAW)	 	* _yaw_scale,   -1.0f, 1.0f),
		math::constrain(get_control(0, actuator_controls_s::INDEX_Z_THRUST) * _x_scale, 	-1.0f, 1.0f),	
		math::constrain(get_control(0, actuator_controls_s::INDEX_Y_THRUST) * _y_scale, 	-1.0f, 1.0f),		
		math::constrain(get_control(0, actuator_controls_s::INDEX_Z_THRUST) * _z_scale, 	-1.0f, 1.0f),		
	};

	matrix::Vector<float, 6> command(command_);

	return command;
}


matrix::Vector<float, 6> 
MultirotorMixer6dof::desaturate_command(const matrix::Vector<float, 6>& desired_command) const
{
	// Copy desired command (potentially saturates motors)
	matrix::Vector<float, 6> command = desired_command;

	// This command should not saturate any motor [0 0 0 0 0 -0.5] should be fine in most cases
	matrix::Vector<float, 6> baseline_command;
	baseline_command(Z_COMMAND) = -0.5f;

	// TODO
	// Copy certain elements of command into baseline_command to give them priority
	// for example if baseline_command, with roll and pitch from command is not saturating, use that as baseline
	// then, try to copy z thrust elements
	// then, try to copy yaw element
	// etc...

	// The unit vector u is used to drive the command towards the non-saturated zone when the command saturates at least one motor
	// command = baseline_command + k * u 
	// where k is a scalar equal 1 when there is no saturation 
	matrix::Vector<float, 6> u = command - baseline_command;
	u.unit();
	
	// apply first mix to capture saturation	
	for (unsigned i = 0; i < _rotor_count; i++) {
		// rotor scale, b is the vector normal to the saturation planes
		const matrix::Vector<float, 6> b(_rotors[i].scale);

		// motor command
		float out = command * b;

		// if motor is saturated			
		// bring command closer to baseline_command in order to un-saturate this motor
		if (out > 1.0f) {
			float ub = u * b;
			if (fabsf(ub) > 1e-6f) {
				float k = (1.0f - baseline_command * b) / ub;
				command = baseline_command + k * u;
			}
		} else if (out < 0.0f) {
			float ub = u * b;
			if (fabsf(ub) > 1e-6f) {
				float k = (0.0f - baseline_command * b) / ub;
				command = baseline_command + k * u;
			}
		}
	}

	return command;
}


unsigned
MultirotorMixer6dof::mix(float *outputs, unsigned space)
{
	/* Summary of mixing strategy:
	The command is represented as a vector y of dimension 6 (roll pitch yaw x y z).
	Scale factors for rotor i are represented as a vector b_i of dimension 6.
	Each rotor vector is normal to 2 planes defined as (y . b_i) = 1 (high motor saturation) and (y . b_i) = 0 (low motor saturation), 
	The command vector y should be between these two planes so that motor i is not saturated.
	Baseline command y_s is a command that does not saturate any motor.
	1) for each rotor:
	   a) mix roll, pitch yaw and thrust (out_i = y . b_i)
	   b) if the output violate range [0,1] then shift the command towards the baseline command 
	      so that the new command is on one of the two saturation planes for this motor.
	3) recompute all outputs with new command
	4) scale all outputs to range [idle_speed,1]
	*/
	
	// Get raw command
	matrix::Vector<float, 6> command = get_command();

	// Make sure the command is in the feaseable actuation space
	command = desaturate_command(command);

	// Compute mixing
	for (unsigned i = 0; i < _rotor_count; i++) {
		// rotor scale, b is the vector normal to the saturation planes	
		const matrix::Vector<float, 6> b(_rotors[i].scale);		

		// motor command		
		outputs[i] = command * b;

		/*
			implement simple model for static relationship between applied motor pwm and motor thrust
			model: thrust = (1 - _thrust_factor) * PWM + _thrust_factor * PWM^2
			this model assumes normalized input / output in the range [0,1] so this is the right place
			to do it as at this stage the outputs are in that range.
		 */
		if (_thrust_factor > 0.0f) {
			outputs[i] = -(1.0f - _thrust_factor) / (2.0f * _thrust_factor) + sqrtf((1.0f - _thrust_factor) *
					(1.0f - _thrust_factor) / (4.0f * _thrust_factor * _thrust_factor) + (outputs[i] < 0.0f ? 0.0f : outputs[i] /
							_thrust_factor));
		}

		// scale output to range [idle_speed, 1]
		outputs[i] = math::constrain(_idle_speed + (outputs[i] * (1.0f - _idle_speed)), _idle_speed, 1.0f);
	}

	// clean out class variable used to capture saturation
	_saturation_status.value = 0;
		
	// slew rate limiting and saturation checking
	for (unsigned i = 0; i < _rotor_count; i++) {
		bool clipping_high = false;
		bool clipping_low = false;

		// check for saturation against static limits
		if (outputs[i] > 0.99f) {
			clipping_high = true;

		} else if (outputs[i] < _idle_speed + 0.01f) {
			clipping_low = true;

		}

		// check for saturation against slew rate limits
		if (_delta_out_max > 0.0f) {
			float delta_out = outputs[i] - _outputs_prev[i];

			if (delta_out > _delta_out_max) {
				outputs[i] = _outputs_prev[i] + _delta_out_max;
				clipping_high = true;

			} else if (delta_out < -_delta_out_max) {
				outputs[i] = _outputs_prev[i] - _delta_out_max;
				clipping_low = true;

			}
		}

		_outputs_prev[i] = outputs[i];

		// update the saturation status report
		update_saturation_status(i, clipping_high, clipping_low);
	}

	// this will force the caller of the mixer to always supply new slew rate values, otherwise no slew rate limiting will happen
	_delta_out_max = 0.0f;

	return _rotor_count;
}

/*
 * This function update the control saturation status report using the following inputs:
 *
 * index: 0 based index identifying the motor that is saturating
 * clipping_high: true if the motor demand is being limited in the positive direction
 * clipping_low: true if the motor demand is being limited in the negative direction
*/
void
MultirotorMixer6dof::update_saturation_status(unsigned index, bool clipping_high, bool clipping_low)
{
	// The motor is saturated at the upper limit
	// check which control axes and which directions are contributing
	if (clipping_high) {
		// At least one motor is saturated at the upper limit
		_saturation_status.flags.motor_pos = true;
		
		if (_rotors[index].scale[ROLL_COMMAND] > 0.0f) {
			// A positive change in roll will increase saturation
			_saturation_status.flags.roll_pos = true;

		} else if (_rotors[index].scale[ROLL_COMMAND] < 0.0f) {
			// A negative change in roll will increase saturation
			_saturation_status.flags.roll_neg = true;
		}

		// check if the pitch input is saturating
		if (_rotors[index].scale[PITCH_COMMAND] > 0.0f) {
			// A positive change in pitch will increase saturation
			_saturation_status.flags.pitch_pos = true;

		} else if (_rotors[index].scale[PITCH_COMMAND] < 0.0f) {
			// A negative change in pitch will increase saturation
			_saturation_status.flags.pitch_neg = true;
		}

		// check if the yaw input is saturating
		if (_rotors[index].scale[YAW_COMMAND] > 0.0f) {
			// A positive change in yaw will increase saturation
			_saturation_status.flags.yaw_pos = true;

		} else if (_rotors[index].scale[YAW_COMMAND] < 0.0f) {
			// A negative change in yaw will increase saturation
			_saturation_status.flags.yaw_neg = true;
		}

		// check if the x input is saturating
		if (_rotors[index].scale[X_COMMAND] > 0.0f) {
			// A positive change in x will increase saturation
			_saturation_status.flags.x_thrust_pos = true;

		} else if (_rotors[index].scale[X_COMMAND] < 0.0f) {
			// A negative change in x will increase saturation
			_saturation_status.flags.x_thrust_neg = true;
		}

		// check if the y input is saturating
		if (_rotors[index].scale[Y_COMMAND] > 0.0f) {
			// A positive change in y will increase saturation
			_saturation_status.flags.y_thrust_pos = true;

		} else if (_rotors[index].scale[Y_COMMAND] < 0.0f) {
			// A negative change in y will increase saturation
			_saturation_status.flags.y_thrust_neg = true;
		}

		// check if the z input is saturating
		if (_rotors[index].scale[Z_COMMAND] > 0.0f) {
			// A positive change in z will increase saturation
			_saturation_status.flags.z_thrust_pos = true;
			
		} else if (_rotors[index].scale[Z_COMMAND] < 0.0f) {
			// A negative change in z will increase saturation
			_saturation_status.flags.z_thrust_neg = true;
		}
	}

	// The motor is saturated at the lower limit
	// check which control axes and which directions are contributing
	if (clipping_low) {
		// At least one motor is saturated at the lower limit
		_saturation_status.flags.motor_neg = true;
		
		// check if the roll input is saturating
		if (_rotors[index].scale[ROLL_COMMAND] > 0.0f) {
			// A negative change in roll will increase saturation
			_saturation_status.flags.roll_neg = true;

		} else if (_rotors[index].scale[ROLL_COMMAND] < 0.0f) {
			// A positive change in roll will increase saturation
			_saturation_status.flags.roll_pos = true;
		}

		// check if the pitch input is saturating
		if (_rotors[index].scale[PITCH_COMMAND] > 0.0f) {
			// A negative change in pitch will increase saturation
			_saturation_status.flags.pitch_neg = true;

		} else if (_rotors[index].scale[PITCH_COMMAND] < 0.0f) {
			// A positive change in pitch will increase saturation
			_saturation_status.flags.pitch_pos = true;
		}

		// check if the yaw input is saturating
		if (_rotors[index].scale[YAW_COMMAND] > 0.0f) {
			// A negative change in yaw will increase saturation
			_saturation_status.flags.yaw_neg = true;

		} else if (_rotors[index].scale[YAW_COMMAND] < 0.0f) {
			// A positive change in yaw will increase saturation
			_saturation_status.flags.yaw_pos = true;
		}

		// check if the x input is saturating
		if (_rotors[index].scale[X_COMMAND] > 0.0f) {
			// A negative change in x will increase saturation
			_saturation_status.flags.x_thrust_neg = true;

		} else if (_rotors[index].scale[X_COMMAND] < 0.0f) {
			// A positive change in x will increase saturation
			_saturation_status.flags.x_thrust_pos = true;
		}

		// check if the y input is saturating
		if (_rotors[index].scale[Y_COMMAND] > 0.0f) {
			// A negative change in y will increase saturation
			_saturation_status.flags.y_thrust_neg = true;

		} else if (_rotors[index].scale[Y_COMMAND] < 0.0f) {
			// A positive change in y will increase saturation
			_saturation_status.flags.y_thrust_pos = true;
		}
						
		// check if the z input is saturating
		if (_rotors[index].scale[Z_COMMAND] > 0.0f) {
			// A negative change in z will increase saturation
			_saturation_status.flags.z_thrust_neg = true;

		} else if (_rotors[index].scale[Z_COMMAND] < 0.0f) {
			// A positive change in z will increase saturation
			_saturation_status.flags.z_thrust_pos = true;
		}

	}

	_saturation_status.flags.valid = true;
}

void
MultirotorMixer6dof::groups_required(uint32_t &groups)
{
	/* XXX for now, hardcoded to indexes 0-3 in control group zero */
	groups |= (1 << 0);
}

uint16_t MultirotorMixer6dof::get_saturation_status()
{
	return _saturation_status.value;
}
